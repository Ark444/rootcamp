
#define _BSD_SOURCE
#define _POSIX_SOURCE

/* Socket */
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* Bool */
#include <stdbool.h>

/* Wait */
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>

/* Std */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

bool is_running = true;

/* Useless vulnerable function only for the PoC */
void
vuln_call(char const *user_input,
	  int const size) {

  char buf[32];

  memcpy(buf, user_input, size);
}

bool
run_server(int const sock,
	   struct sockaddr_in *addr,
	   socklen_t *addrlen) {

  char buf[1024];
  int clisock, pid, ret;

  while (is_running == true) {
    wait3(NULL, WNOHANG, NULL);
    if ((clisock = accept(sock, (struct sockaddr *)addr, addrlen)) == -1)
      return !is_running;

    if ((pid = fork()) == -1) {
      perror("fork");
      close(clisock);
    } else if (pid == 0) {

      fprintf(stderr, "[+] Client connected\n");

      if ((ret = read(clisock, buf, 1024)) == -1)
	goto end;

      vuln_call(buf, ret);
      if (write(clisock, "Got your buffer\n", 16) == -1) {
	fprintf(stderr, "\tFAILED TO SEND CONFIRMATION BUFFER\n");
      }

    end:
      fprintf(stderr, "[+] Client exited\n");
      close(clisock);
      exit(0);

    }
  }
  return !is_running;
}

int
main(int const argc,
     char const *argv[]) {

  int sock;
  struct sockaddr_in addr;
  socklen_t addrlen;
  unsigned short port = 1024;

  if (argc == 2)
    port = atoi(argv[1]);

  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    perror("socket");
    return 1;
  }

  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addrlen = (socklen_t)sizeof(struct sockaddr_in);
  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    perror("bind");
    return 1;
  }
  if (listen(sock, 5) == -1) {
    perror("listen");
    return 1;
  }
  run_server(sock, &addr, &addrlen);
  close(sock);
  return 0;
}
